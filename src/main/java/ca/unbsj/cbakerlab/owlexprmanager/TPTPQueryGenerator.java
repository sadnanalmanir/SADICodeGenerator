package ca.unbsj.cbakerlab.owlexprmanager;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Graph;
import com.tinkerpop.blueprints.Vertex;
import org.coode.owlapi.manchesterowlsyntax.ManchesterOWLSyntaxClassExpressionParser;
import org.semanticweb.owlapi.model.*;

import java.util.*;

/**
 * Created by sadnana on 15/07/15.
 */
public class TPTPQueryGenerator {

    public Set<OWLClass> classes;
    public Set<OWLDataProperty> dataProperties;
    public Set<OWLObjectProperty> objectProperties;

    public static List<String> cls_predicate_List = new ArrayList<String>();
    // collects answer variables only from the output class description (datatype only)
    public static List<String> answerVars = new ArrayList<String>();

    String includeFiles;
    String queryPrefix;
    String querySuffix;

    public static final String ONT_RDB_MAPPING_FILENAME = "my_university_semantic_map.fof.tptp";
    //public static final String ONT_RDB_MAPPING_FILENAME = "tohdw_haio_semantic_map.fof.tptp";
    public static final String ONT_TO_TPTP_FILENAME = "lubm-sadi-service-ontology.cnf.tptp";
    //public static final String ONT_TO_TPTP_FILENAME = "HAI_no_Illegal_Symbols.ontology.cnf.tptp";


    /**
     * @param inputGraph  set of input graphs
     * @param outputGraph set of output graphs
     * @return TPTP query generated from both input and output graph
     */
    public String generateTPTPQuery(OWLOntology ontology, List<Graph> inputGraph, List<Graph> outputGraph) {


        includeFiles =
                "% mapping of ontology to relation data \n" +
                "include('" + ONT_RDB_MAPPING_FILENAME + "'). \n\n" +
                "% ontology translated into tptp formulas \n" +
                "include('" + ONT_TO_TPTP_FILENAME + "'). \n\n";
        queryPrefix =
                "% semantic query \n" +
                "input_clause(autogeneratedquery,conjecture, \n" + "  [";
        querySuffix = "\n  ]).";




        classes = ontology.getClassesInSignature();
        dataProperties = ontology.getDataPropertiesInSignature();
        objectProperties = ontology.getObjectPropertiesInSignature();


        boolean isOutputClsDescription;

        String tptpQuery = "";
        // generate tptp part of input graph rooted at 'Input' node
        for (Graph igraph : inputGraph) {
            isOutputClsDescription = false;
            List<Edge> ipEdgesList = sortEdgesInDFS(igraph.getEdges());
            addClsPredicatesToList(ipEdgesList, isOutputClsDescription);
        }

        // generate tptp part of input graph rooted at 'Input' node
        for (Graph igraph : outputGraph) {
            isOutputClsDescription = true;
            List<Edge> opEdgesList = sortEdgesInDFS(igraph.getEdges());
            addClsPredicatesToList(opEdgesList, isOutputClsDescription);
        }

        String prefixAtom = "--p_";
        String prefixAnswer = "++";
        tptpQuery += createTPTPfof(prefixAtom, prefixAnswer, cls_predicate_List, answerVars);


        return includeFiles + queryPrefix + tptpQuery + querySuffix;
    }


    private void addClsPredicatesToList(List<Edge> edgesList, boolean isOutputClsDescription) {
        for (Edge edge : edgesList) {
            // consider only data and object property edge, other edges have no labels
            if (!edge.getLabel().equals("")) {
                // if the edge label is an object property
                if (!checkPropertyType(objectProperties, dataProperties, edge.getLabel())) {
                    // the node with this incoming edge is a class
                    // Input rdf:type Course -> Course(Input)
                    // Alternatively, this can also be done by checking each node if it is a class e.g. Course, Student in the graph and
                    // if they are, then create an unary predicate Course(edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString())
                    if (edge.getLabel().equals("type")) {

                        cls_predicate_List.add(edge.getVertex(Direction.IN).getProperty("name").toString() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ")");

                    }
                    // A subClassOf B ->  A(p)=>B(p)
                    else if (edge.getLabel().equals("subClassOf")) {
                        System.out.println("Predicate generation for subClassOf NOT implemented yet");
                    }
                    // Input courseTaken CommonResource1 -> courseTaken(Input, CommonResource1)
                    else {
                        cls_predicate_List.add(edge.getLabel() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ", " + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase()  + ")");
                    }
                    // for the data property add Val + the name of the node stored as a vertex property nodeVariableName
                } else {

                    if(!isOutputClsDescription)
                        cls_predicate_List.add(edge.getLabel() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ", " + "\"" + "val" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString() + "\"" + ")");
                    else
                        cls_predicate_List.add(edge.getLabel() + "(" + edge.getVertex(Direction.OUT).getProperty("nodeVariableName").toString().toUpperCase() + ", " + "VAL" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase() + ")");
                    // add to the list of answer variables if data property is in output class description
                    if(isOutputClsDescription)
                        answerVars.add("VAL" + edge.getVertex(Direction.IN).getProperty("nodeVariableName").toString().toUpperCase());

                }

            }

        }

    }

    private String createTPTPfof(String prefixAtom, String prefixAnswer, List<String> cls_predicate_list, List<String> answerVars) {
        String query = "";

        for(int i = 0; i < cls_predicate_list.size(); i++){
            query += (i > 0)? "," + "\n\t" + prefixAtom + cls_predicate_list.get(i) :  "\n\t" +prefixAtom + cls_predicate_list.get(i);
        }

        query +=  ", " + "\n\t" + prefixAnswer  + "answer" + "(";
        for(int i = 0; i < answerVars.size(); i++){
            query += (i > 0)? "," + answerVars.get(i) : answerVars.get(i);
        }

        query += ")";

        return query;
    }


    /**
     * @param edges
     * @return sort the edges of the graph in ordre of generation i.e. DFS
     */
    private static List<Edge> sortEdgesInDFS(Iterable<Edge> edges) {
        List<Edge> sortedEdges = new ArrayList<Edge>();

        for (Edge e : edges) {
            sortedEdges.add(e);
        }

        Collections.sort(sortedEdges, new Comparator<Edge>() {
            public int compare(Edge e1, Edge e2) {
                //based on number of edge ID
                return Integer.parseInt(e1.getId().toString()) - Integer.parseInt(e2.getId().toString());
            }
        });
        return sortedEdges;
    }


    /**
     * @param objectProperties set of object properties
     * @param dataProperties   set of data properties
     * @param propertyLabel    edge label i.e. property name
     * @return ture if the edge/property is data property
     */
    private boolean checkPropertyType(Set<OWLObjectProperty> objectProperties, Set<OWLDataProperty> dataProperties, String propertyLabel) {
        boolean result = false;

        for (OWLDataProperty dp : dataProperties) {
            if (dp.getIRI().getFragment().equals(propertyLabel)) {
                result = true;
            }
        }
        for (OWLObjectProperty op : objectProperties) {
            if (op.getIRI().getFragment().equals(propertyLabel)) {
                result = false;
            }
        }
        return result;
    }
}